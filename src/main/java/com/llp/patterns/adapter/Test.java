package com.llp.patterns.adapter;

/**
 * 作者： Joinly
 * 时间： 2016/7/28
 * 描述： ${todo}.
 */
public class Test {

    /****
     * 类适配器和对象适配器的权衡

     类适配器使用对象集成的方式，是静态的定义方式；而对象适配器使用对象组合的方式，是动态组合的方式。
     对于类适配器，由于适配器直接继承了Adaptee，使得适配器不能和Adaptee的子类一起工作，因为继承是静态的关系，当适配器继承了Adaptee后，就不能再取处理Adaptee的子类了。对于对象适配器，一个适配器可以把多种不同的源适配到同一个目标。换言之，同一个适配器可以把源类和它的子类都适配到目标接口。因为对象适配器采用的是对象组合的关系，只要对象类型正确，是不是子类都无所谓。
     对于类适配器，适配器可以重定义Adaptee的部分行为，想当于子类覆盖父类的部分实现方法。对于对象适配器，要重定义Adaptee的行为比较困难，这种情况下，需要定义Adaptee的子类来实现重定义，然后让适配器组合子类。虽然重定义Adaptee的行为比较困难，但是想要增加一些新的行为则方便的很，而且新增加的行为可同时适用于所有的源。
     对于类适配器，仅仅引入了一个对象，并不需要额外的引用来间接得到Adaptee，对于对象适配器，需要额外的引用来间接得到Adaptee。
     总结：建议尽量使用对象适配器的实现方式，符合CARP原则。
     *
     *
     * 总结
     ?优点：更好的复用性：系统需要使用现有的类，而此类的接口不符合系统的需要。那么通过适配器模式就可以让这些功能得到更好的复用。更好的扩展性：在实现适配器功能的时候，可以调用自己开发的功能，从而自然地扩展系统的功能。
     ?缺点：过多的使用适配器，会让系统非常零乱，不易整体进行把握。如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。

     适用场景

     你想使用一个已经存在的类，而它的接口不符合你的需求
     你想创建一个可以复用的类，该类可以与其他不相关的类或不可预见的类协同工作。
     （仅使用与对象Adapter）你想使用一些已经存在的子类，但是不可能对每一个都进行子类化以匹配它们的接口。
     * ***/

    public static void main(String[] args) {

        /*
        Adapter adapter = new Adapter();
        adapter.operate();
        */

        Adaptee adaptee = new Adaptee();
        ObjectAdapter adapter = new ObjectAdapter(adaptee);
        adapter.operate();
    }
}
